/**
 * CSS selector utilities for Inspector Jake.
 * Single source of truth for building stable CSS selectors.
 *
 * Used by both the Chrome extension content script and DevTools panel.
 */

/**
 * Escape a string for use in CSS selectors.
 * Polyfill for cssEscape() that works in Node.js environments.
 */
function cssEscape(value: string): string {
  // Use native cssEscape if available (browser environment)
  if (typeof CSS !== 'undefined' && typeof cssEscape === 'function') {
    return cssEscape(value);
  }

  // Simple polyfill for Node.js
  // Based on https://drafts.csswg.org/cssom/#serialize-an-identifier
  return value.replace(/([^\x20-\x7E]|[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~])/g, '\\$1');
}

/**
 * Check if an ID looks auto-generated and should be avoided in selectors.
 * Auto-generated IDs include UUIDs, long hex strings, and numeric-prefixed IDs.
 */
export function isAutoGeneratedId(id: string): boolean {
  // Matches UUIDs, long hex strings (20+ chars)
  if (/^[a-f0-9-]{20,}$/i.test(id)) return true;
  // Matches numeric-prefixed IDs
  if (/^\d/.test(id)) return true;
  return false;
}

/**
 * Filter classes to stable ones suitable for CSS selectors.
 * Filters out:
 * - Pseudo-class prefixes (hover:, focus:, etc.)
 * - Classes with long numeric sequences (likely auto-generated)
 * - Empty classes
 */
export function filterStableClasses(className: string, maxCount = 2): string[] {
  if (!className || typeof className !== 'string') return [];

  const trimmed = className.trim();
  if (!trimmed) return [];

  return trimmed
    .split(/\s+/)
    .filter((c) => {
      // Skip empty
      if (!c) return false;
      // Skip pseudo-class prefixes (Tailwind hover:, focus:, etc.)
      if (c.includes(':')) return false;
      // Skip classes with 3+ digit sequences (likely auto-generated)
      if (/\d{3,}/.test(c)) return false;
      return true;
    })
    .slice(0, maxCount);
}

/**
 * Context for building a selector part.
 * Abstraction layer that works in both DOM and non-DOM contexts.
 */
export interface SelectorContext {
  /** Element tag name (e.g., 'button', 'div') */
  tagName: string;
  /** Element ID (optional) */
  id?: string | null;
  /** Element className string (optional) */
  className?: string | null;
  /** Get attribute by name (optional, for data-testid) */
  getAttribute?: (name: string) => string | null;
  /** 1-based index among same-tag siblings (optional) */
  siblingIndex?: number;
  /** Count of same-tag siblings (optional) */
  siblingCount?: number;
}

/**
 * Build a simple selector part for a single element.
 * Context-free - works with any element-like object.
 *
 * Priority order:
 * 1. Stable ID (not auto-generated)
 * 2. data-testid or data-test-id attribute
 * 3. Stable classes (max 2)
 * 4. nth-of-type if multiple siblings
 * 5. Just the tag name
 */
export function buildSelectorPart(ctx: SelectorContext): string {
  const tag = ctx.tagName.toLowerCase();

  // 1. Prefer stable ID (not auto-generated)
  if (ctx.id && !isAutoGeneratedId(ctx.id)) {
    return `${tag}#${cssEscape(ctx.id)}`;
  }

  // 2. Use data-testid if available
  const testId =
    ctx.getAttribute?.('data-testid') || ctx.getAttribute?.('data-test-id');
  if (testId) {
    return `${tag}[data-testid="${testId}"]`;
  }

  // 3. Use stable classes (max 2)
  const classes = filterStableClasses(ctx.className || '');
  if (classes.length > 0) {
    return `${tag}.${classes.map((c) => cssEscape(c)).join('.')}`;
  }

  // 4. Fall back to nth-of-type if multiple siblings with same tag
  if (ctx.siblingCount && ctx.siblingCount > 1 && ctx.siblingIndex) {
    return `${tag}:nth-of-type(${ctx.siblingIndex})`;
  }

  // 5. Just the tag name
  return tag;
}
